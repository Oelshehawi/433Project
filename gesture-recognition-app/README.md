# CMPT 433 Project - Gesture Recognition

This C++ App uses Open CV for Gesture Recognition.
Also note that the project currently uses a usb webcam, with potential use of the LCD in a future iteration.

## Steps to test the webcam

When plugged into the bottom left USB port on the Beagle Board's USB Hub, 
a USB Webcam can be accessed and tested as follows: 

Step 1: Confirm Camera is Detected:

`(byai)$ ls /dev/video*`
or
`lsusb`

Step 2: Test the webcam by taking a screenshot and saving to a mounted folder 
connected between the beagle board and the host VM. 

`fswebcam -d /dev/video3 -r 640x480 --jpeg 85 /mnt/remote/pictures/test.jpg`

Step 3: Then check the mounted directory on host to see the image:

`ls -lh ~/cmpt433/public/pictures/`



## Steps to Add LCD to an Existing Project

1. Load the SPI Overlay on the board (just do once)
  a. Edit config file:
     `(byai)$ sudo nano /boot/firmware/extlinux/extlinux.conf`
  b. Edit the last section to make it say:  
     ```
      label microSD (default)
          kernel /Image
          append console=ttyS2,115200n8 root=/dev/mmcblk1p3 ro rootfstype=ext4 resume=/dev/mmcblk1p2 rootwait net.ifnames=0 quiet
          fdtdir /
          fdt /ti/k3-am67a-beagley-ai.dtb
          fdtoverlays /overlays/k3-am67a-beagley-ai-spidev0.dtbo
          initrd /initrd.img
     ```
     (If you are also enabling PWM, make the `fdtoverlays` line be a space-separated list of .dtbo files.)
  c. Reboot.   
  d. You should now have two files: `/dev/spidev0.0` and `/dev/spidev0.1`.  
2. Copy `lcd/` and `lgpio/` folders into project.
3. In root `CMakeLists.txt`, add:  
  ```
  add_subdirectory(lgpio)
  add_subdirectory(lcd)
  ```
4. Into your `app/CMakeLists.txt`, add:  
  ```
  target_link_libraries(hello_world LINK_PRIVATE lcd)
  target_link_libraries(hello_world LINK_PRIVATE lgpio)
  ```
  (Changing `hello_world` to your project's name)
5. Create a module to interact with the screen (base on `draw_stuff.h/.c`, but name it better!)  
6. Add calls to init and cleanup to your main().
7. Trigger a CMake rebuild so it will compile your new files.


## Steps to add Open CV to the project:

How to Install OpenCV & MediaPipe in C++:

Run these commands on the host VM terminal:

```
sudo apt update
sudo apt install -y libopencv-dev
```

Then install MediaPipe C++ dependencies:

```
sudo apt install -y cmake g++ wget unzip
```

Modify CMakeLists.txt in the app directory to include OpenCV & MediaPipe:

```
find_package(OpenCV REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

target_link_libraries(light_sampler PRIVATE ${OpenCV_LIBS})
```


## Running on Target

* Install the lgpio library on the target
  `(byai)$ sudo apt install liblgpio-dev`
* At each boot you'll need to either:
  a. Change the SPI to be usable by anyone:
     `sudo chmod a+rw /dev/spidev0.*`
  b. Run the program with root access.




## Structure

- `hal/`:   Contains all low-level hardware abstraction layer (HAL) modules
- `app/`:   Contains all application-specific code. Broken into modules and a main file
- `build/`: Generated by CMake; stores all temporary build files (may be deleted to clean)
- `lcd/`:   Library for LCD use from https://www.waveshare.com/   **temporarily removed until Main functionality works
- `lgpio/`: Library used by LCD code, from https://github.com/joan2937/lg/archive/master.zip **temporarily removed until Main functionality works
            (No need to install the library on the host)

```
  
gesture-recognition-app/
├── app/                      # Application logic
│   ├── include/
│   │   ├── gesture.h
│   │   ├── udp_sender.h
│   ├── src/
│   │   ├── gesture.cpp
│   │   ├── udp_sender.cpp
│   │   ├── main.cpp
│   ├── CMakeLists.txt
├── hal/                      # Hardware Abstraction Layer
│   ├── include/hal/
│   │   ├── camera_hal.h
│   ├── src/
│   │   ├── camera_hal.cpp
│   ├── CMakeLists.txt
├── lcd/                      # LCD module   **temporarily removed until Main functionality works
├── lgpio/                    # Library to support LCD **temporarily removed until Main functionality works
├── build/                    # Compilation output
├── CMakeLists.txt            # Root CMake
├── README.md


```  

Note: This application is just to help you get started! It also has a bug in its computation (just for fun!)

## Usage

- Install CMake: `sudo apt update` and `sudo apt install cmake`
- When you first open the project, click the "Build" button in the status bar for CMake to generate the `build\` folder and recreate the makefiles.
  - When you edit and save a CMakeLists.txt file, VS Code will automatically update this folder.
- When you add a new file (.h or .c) to the project, you'll need to rerun CMake's build
  (Either click "Build" or resave `/CMakeLists.txt` to trigger VS Code re-running CMake)
- Cross-compile using VS Code's CMake addon:
  - The "kit" defines which compilers and tools will be run.
  - Change the kit via the menu: Help > Show All Commands, type "CMake: Select a kit".
    - Kit "GCC 10.2.1 arm-linux-gnueabi" builds for target.
    - Kit "Unspecified" builds for host (using default `gcc`).
  - Most CMake options for the project can be found in VS Code's CMake view (very left-hand side).
- Build the project using Ctrl+Shift+B, or by the menu: Terminal > Run Build Task...
  - If you try to build but get an error about "build is not a directory", the re-run CMake's build as mentioned above.



## Address Sanitizer

- The address sanitizer built into gcc/clang is very good at catching memory access errors.
- Enable it by uncomment the `fsanitize=address` lines in the root CMakeFile.txt.
- For this to run on the BeagleBone, you must run:
  `sudo apt install libasan6`
  - Without this installed, you'll get an error:   
    "error while loading shared libraries: libasan.so.6: cannot open shared object file: No such file or directory"

## Suggested addons

- "CMake Tools" automatically suggested when you open a `CMakeLists.txt` file
- "Output Colourizer" by IBM 
    --> Adds colour to the OUTPUT panel in VS Code; useful for seeing CMake messages

## Other Suggestions

- If you are trying to build with 3rd party libraries, you may want to consider the 
  build setup suggested at the following link. Specificall, see the part on 
  extracting the BB image to a folder, and then using chroot to run commands like
  `apt` on that image, which allows you to get libraries for the target on the build system.
  https://takeofftechnical.com/x-compile-cpp-bbb/

## Manually Running CMake

To manually run CMake from the command line use:

```shell
  # Regenerate build/ folder and makefiles:
  rm -rf build/         # Wipes temporary build folder
  cmake -S . -B build   # Generate makefiles in build\

  # Build (compile & link) the project
  cmake --build build
```

## Finer Points

- When using the header files in HAL, you'll need to:  
  `#include "hal/myfile.h`  
  This extra "hal/..." helps distinguish the low-level access from the higher-level code.
- One only need to run the CMake build the first time the project loads, and each time the .h and .c file names change, or new ones are added, or ones are removed. This regenerates the `build/Makefile`. Otherwise, just run a normal build (ctrl+shift+B)
- If desired, one could provide an alternative implementation for the HAL modules that provides a software simulation of the hardware! This could be a useful idea if you have some complex hardware, or limited access to some hardware.
